<!DOCTYPE html>
<html>
<head>
    <script src="http://127.0.0.1:8080/js/three.js"></script>
    <script src="http://127.0.0.1:8080/js/PointerLockControlsByUlisse.js"></script>

    <style>
            html, body {
                width: 100%;
                height: 100%;
            }

            body {
                background-color: #ffffff;
                margin: 0;
                overflow: hidden;
                font-family: arial;
            }

            #blocker {

                position: absolute;

                width: 100%;
                height: 100%;

                background-color: rgba(0,0,0,0.5);

            }

            #instructions {

                width: 100%;
                height: 100%;

                display: -webkit-box;
                display: -moz-box;
                display: box;

                -webkit-box-orient: horizontal;
                -moz-box-orient: horizontal;
                box-orient: horizontal;

                -webkit-box-pack: center;
                -moz-box-pack: center;
                box-pack: center;

                -webkit-box-align: center;
                -moz-box-align: center;
                box-align: center;

                color: #ffffff;
                text-align: center;

                cursor: pointer;

            }
    </style>
</head>
<body>
<div id="blocker">

            <div id="instructions">
                <span style="font-size:40px">Click to play</span>
                <br/>
                (W, A, S, D = Move, SPACE = Jump, MOUSE = Look around)
            </div>

        </div>
    <script>

        var MovingCube;
        var collidableMeshList = [];

        var camera, scene, renderer;
        var geometry, material, mesh;

        var manopola;

        var point;

            var controls,time = Date.now();

            var objects = [];

            var ray;

            var blocker = document.getElementById( 'blocker' );
            var instructions = document.getElementById( 'instructions' );

            // http://www.html5rocks.com/en/tutorials/pointerlock/intro/

        var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;

            if ( havePointerLock ) {

                var element = document.body;

                var pointerlockchange = function ( event ) {

                    if ( document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element ) {

                        controls.enabled = true;

                        blocker.style.display = 'none';

                    } else {

                        controls.enabled = false;

                        blocker.style.display = '-webkit-box';
                        blocker.style.display = '-moz-box';
                        blocker.style.display = 'box';

                        instructions.style.display = '';

                    }

                }

                var pointerlockerror = function ( event ) {

                    instructions.style.display = '';

                }

                // Hook pointer lock state change events
                document.addEventListener( 'pointerlockchange', pointerlockchange, false );
                document.addEventListener( 'mozpointerlockchange', pointerlockchange, false );
                document.addEventListener( 'webkitpointerlockchange', pointerlockchange, false );

                document.addEventListener( 'pointerlockerror', pointerlockerror, false );
                document.addEventListener( 'mozpointerlockerror', pointerlockerror, false );
                document.addEventListener( 'webkitpointerlockerror', pointerlockerror, false );

                instructions.addEventListener( 'click', function ( event ) {

                    instructions.style.display = 'none';

                    // Ask the browser to lock the pointer
                    element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;

                    if ( /Firefox/i.test( navigator.userAgent ) ) {

                        var fullscreenchange = function ( event ) {

                            if ( document.fullscreenElement === element || document.mozFullscreenElement === element || document.mozFullScreenElement === element ) {

                                document.removeEventListener( 'fullscreenchange', fullscreenchange );
                                document.removeEventListener( 'mozfullscreenchange', fullscreenchange );

                                element.requestPointerLock();
                            }

                        }

                        document.addEventListener( 'fullscreenchange', fullscreenchange, false );
                        document.addEventListener( 'mozfullscreenchange', fullscreenchange, false );

                        element.requestFullscreen = element.requestFullscreen || element.mozRequestFullscreen || element.mozRequestFullScreen || element.webkitRequestFullscreen;

                        element.requestFullscreen();

                    } else {

                        element.requestPointerLock();

                    }

                }, false );

            } else {

                instructions.innerHTML = 'Your browser doesn\'t seem to support Pointer Lock API';

            }



        init();

        

        animate();

        function init() {

            //camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 10000 );
            //camera.applyMatrix( new THREE.Matrix4().makeTranslation(400, 400, 400) );

            var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
            var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;
            camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);

/*
            var cubeGeometry = new THREE.CubeGeometry(50,50,50,1,1,1);
            var wireMaterial = new THREE.MeshBasicMaterial( { color: 0xff0000, wireframe:true } );
            MovingCube = new THREE.Mesh( cubeGeometry, wireMaterial );
            MovingCube.position.set(0, 5, 0);
            MovingCube.add(camera);
            
    */

            scene = new THREE.Scene();

            controls = new THREE.PointerLockControls( camera );
            scene.add( controls.getObject() );

            ray = new THREE.Raycaster();
                ray.ray.direction.set( 0, -1, 0 );

            
            //floor
               
            var plane = new THREE.Mesh(
                new THREE.PlaneGeometry(1000, 1000, 100, 100),
                new THREE.MeshLambertMaterial({color: 0xFFFFFF})
                );
            plane.rotation.x = -Math.PI / 2;
            plane.position.y = 0;
            plane.receiveShadow = true;
            scene.add(plane);


            loader = new THREE.JSONLoader();

            loader.load( "http://127.0.0.1:8080/modelli/tardis.js", function( geometry, materials ) {

                    //var geometry = new THREE.CubeGeometry(5,10,5);

                mesh = new THREE.Mesh( geometry, new THREE.MeshFaceMaterial( materials ) );
                //mesh = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { color: 0xff0000, wireframe: true } ) );
                mesh.scale.set( 50, 50, 50 );
                mesh.position.y = 0;
                mesh.position.x = 0;
                mesh.position.z = 0;
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                collidableMeshList.push(mesh); /////////////////////
                scene.add( mesh );

        } );
            
            
            loader.load( "modelli/manopola.js", function( geometry, materials ) {

                    //var geometry = new THREE.CubeGeometry(5,10,5);
                //geometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, 10, 0 ) );
                mesh = new THREE.Mesh( geometry, new THREE.MeshFaceMaterial( materials ) );
                //mesh = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { color: 0xff0000, wireframe: true } ) );
                
                manopola = mesh;

                mesh.scale.set( 2, 2, 2 );
                mesh.position.y = 0;
                mesh.position.x = 0;
                collidableMeshList.push(mesh); /////////////////7
                scene.add( mesh );

        } );


            var spotlight = new THREE.SpotLight(0xffffff);
            spotlight.position.set(500,500,30);
            //spotlight.shadowCameraVisible = true;
            //spotlight.shadowDarkness = 0.25;
            //spotlight.intensity = 10;
            //spotlight.shadowCameraFov = 100;
            // must enable shadow casting ability for the light
            spotlight.castShadow = true;
            scene.add(spotlight);

            renderer = new THREE.WebGLRenderer({antialias: true});
            renderer.setSize( window.innerWidth, window.innerHeight );
            renderer.shadowMapEnabled = true;
            document.body.appendChild( renderer.domElement );

            window.addEventListener( 'resize', onWindowResize, false );

        }

        /*
        function animate() {

            // note: three.js includes requestAnimationFrame shim
            requestAnimationFrame( animate );

            //mesh.rotation.x += 0.01;
            //mesh.rotation.y += 0.02;

            renderer.render( scene, camera );

        }
        */



        function onWindowResize() {

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize( window.innerWidth, window.innerHeight );

            }

            window.addEventListener("click",function(e){ 
            if(controls.enabled==true){
                
                var point = new THREE.Mesh(new THREE.BoxGeometry( 5, 5, 5 ), new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ));
                point.position.x=10;
                point.position.y=10;
                scene.add(point);
            }
        });

        function animate() {

            requestAnimationFrame( animate );

            //

            controls.isOnObject( false );

            ray.ray.origin.copy( controls.getObject().position );
            ray.ray.origin.y -= 10;
            /*
            var intersections = ray.intersectObjects( objects );

            if ( intersections.length > 0 ) {

                var distance = intersections[ 0 ].distance;

                if ( distance > 0 && distance < 10 ) {

                    controls.isOnObject( true );

                }

            }
*/
           
            
            controls.update( Date.now() - time );

            renderer.render( scene, camera );

            time = Date.now();

        }

        function collision( wallArray )
        {
            

            // send rays from center of person to each vertex in bounding geometry
            for (var vertexIndex = 0; vertexIndex < MovingCube.geometry.vertices.length; vertexIndex++)
            {       
                var localVertex = MovingCube.geometry.vertices[vertexIndex].clone();
                var globalVertex = localVertex.applyMatrix4( MovingCube.matrix );
                var directionVector = globalVertex.sub( MovingCube.position );
                
                var ray = new THREE.Raycaster( MovingCube.position, directionVector.clone().normalize() );
                var collisionResults = ray.intersectObjects( collidableMeshList );
                if ( collisionResults.length > 0 && collisionResults[0].distance < directionVector.length() ) 
                    return true;
            }   
            return false;
        }

    </script>
</body>
</html>
